Verifying the VeeR core
-----------------------

This example uses the `VeeR EH1 RISC-V Core`_.  In a new folder, run ``git clone
https://github.com/chipsalliance/Cores-VeeR-EH1``.

.. _VeeR EH1 RISC-V Core: https://github.com/chipsalliance/Cores-VeeR-EH1

.. note::

    This example requires Yosys built with Verific for parsing the input design.
    Ask us for an `evaluation license`_ for TabbyCAD to try this yourself.

.. _evaluation license: https://www.yosyshq.com/contact

Loading the design
~~~~~~~~~~~~~~~~~~

In the same directory as ``Cores-VeeR-EH1``, run ``sby --init-config-file
veer``.  This will produce a file, ``veer.sby`` with the following content:

.. literalinclude:: _examples/veer_1.sby
    :language: sby
    :caption: ``veer.sby`` generated from ``sby --init-config-file veer``

Next up we need to add all of the files to ``veer.sby`` and read them into
Yosys.  The VeeR core comes with a handy |veer.core|_ file which lists all of
the RTL source and includes needed.  We're going to make a command file called
``veer.f`` which we can read with Verific to load all of our source files
together.

First, we start with the include directories.  Both include files listed are in
the ``design/include/`` directory, so we can use a single
``+incdir+design/include``.  Next we want to list all of the source files: copy
the list from |veer.core|_ and make sure to remove the ``-`` and any indentation
at the start of each line.  You should end up with something like the following:

.. |veer.core| replace:: ``veer.core``
.. _veer.core: https://github.com/chipsalliance/Cores-VeeR-EH1/blob/main/veer.core

.. literalinclude:: _examples/veer_2.sby
    :language: sby
    :start-at: [file veer.f]
    :end-before: [files]

We have included two extra lines in there, one for
``+incdir+snapshots/default``, and one for
``snapshots/default/common_defines.vh``.  The ``snapshots/default`` directory is
generated by the ``configs/veer.config`` perl script and provides macro
definitions which configure the VeeR core as needed.  Provided perl is installed
on the system, we can get Yosys to call this script for us when we run SBY.  We
also need to update the ``[script]`` section to read our new ``veer.f`` command
file and change the top module to ``veer_wrapper``.  This gives us the
following:

.. literalinclude:: _examples/veer_2.sby
    :language: sby
    :start-at: [script]
    :end-before: [file veer.f]

The perl script expects an environment variable, ``RV_ROOT``, which defines the
root location in which to generate.  By using ``bash -c`` we can use the SBY
output directory (accessed via ``$PWD``) as this root location.  The ``-f`` flag
in the ``read`` command is passed to Verific to signal that a command file is
being read.

Finally we have the ``[files]`` section:

.. literalinclude:: _examples/veer_2.sby
    :language: sby
    :start-at: [files]

In addition to the source files in the ``design`` directory, we are also
including the config script in ``configs``, which itself references the files in
the ``tools`` directory.  By defining ``veer.f`` in the SBY file, we skip the
need to include it in the files list.

Running SBY now we might see something like the following:

..
  
    SBY [veer] prep: ERROR: CLK tck on $verific$ir_reg$design/dmi/rvjtag_tap.sv:142$7750 ($dff) from module rvjtag_tap_default also used with opposite polarity, run clk2fflogic instead.

This tells us that we have a clock signal, ``tck`` in this case, which is
triggering on both positive and negative edges.  This means we need to enable
multiclock mode by adding ``multiclock on`` to the ``[options]`` section.  At
this point we can now run BMC and get our first failed counter trace.  The model
checker can start the design in any state, including those which would normally
be unreachable, so it might not be a very useful trace; but we have managed to
successfully get the design all the way to the solvers.

Formal setup
~~~~~~~~~~~~

Depending on the state of your design you may wish to specify additional
properties for the solver.  In particular, we need to set up constraints for the
clock and reset signals.  When using Verific we can do this by binding a module
which provides assumptions on the input signals like so:

.. literalinclude:: _examples/veer_3.sby
    :language: sby
    :start-at: [file formal.sv]
    :end-before: [file veer.f]

Again we are providing a file from within the SBY file and do not need to add it
to the ``[files]`` section.  We do, however, need to tell Verific to read it. We
do this by adding ``formal.sv`` on a new line after ``design/veer_wrapper.sv``
in the ``veer.f`` command file.

First we connect the global clock with the line ``(* gclk *) reg gclk;``.  Each
rising edge of the global clock corresponds to one step (or frame) in the
solver.  By inverting the ``clk`` register on each ``posedge``, each step of the
solver alternates between a rising edge and a falling edge of the ``clk``.  Then
we need to have an assumption which says our top level clock,
``veer_wrapper.clk`` in this case, is equivalent to ``clk``.

We can also add a reset, using a counter to control the number of cycles it
should be held high.  As with the clock, we then add an assumption to the
corresponding top level signal or signals.  If the reset signal is active low
then the assumption should be ``== !rst``.  We can add constraints (assumptions)
or any other property to any signal as follows:

.. code-block:: systemverilog

    always @* begin
        // always high
        assume (top.a);
        // always low
        assert (!top.b);
        // deeply nested
        cover (top.x.y.z);
        // conditional
        if (rst)
            assume (top.c);
    end

    // SVA properties
    assume property(@(posedge clk) disable iff(rst) $rose(top.d) |-> top.e == '0);

Say you wanted to see a list of properties in the design.  This can be achieved
with the ``select`` command in Yosys, using the ``-list`` flag and the ``tee``
option to export to a file.  We might add something like the following to the
``[script]`` section:

.. literalinclude:: _examples/veer_3.sby
    :language: yoscrypt
    :start-at: tee -o
    :end-before: [file formal.sv]

Running SBY now we get the following:

.. literalinclude:: _examples/props.veer_3.txt
    :caption: ``veer/props.txt``

.. literalinclude:: _examples/logfile.veer_3.txt
    :caption: ``veer/logfile.txt``

We can see from this that the ``dma_ctrl`` module is expecting a valid AXI
connection, which is currently missing.  We could add assumptions on the inputs
that match the assertions, but we already have perfectly good properties that we
can use: the assertions themselves.

Changing properties
~~~~~~~~~~~~~~~~~~~

The ``chformal`` command in Yosys enables formal properties to be changed at run
time.  With this command we can convert assertions to assumptions (as well as
the reverse), or entirely remove properties that we are not currently interested
in.

From our previous run we know that the assert cell
``dma_ctrl_default/assert_dma_axi_awlen_check`` fails.  We could add the
following line after calling ``prep`` to remove it:

.. code-block:: yoscrypt

    chformal -remove dma_ctrl_default/assert_dma_axi_awlen_check

But then we would just be left with another assertion in the same module
failing.  This also has the side effect that if anything else in the design is
relying on the (now missing) assertion being correct, it will also fail.
Instead, let's add the following:

.. code-block:: yoscrypt

    chformal -assert -assert2assume dma_ctrl_default/assert_dma_axi_*

We can see from the |cmdref for chformal|_ (or by running calling ``help
chformal`` within Yosys) that we can specify the type of formal property to
target, and that the final argument is a ``selection`` rather than simply the
name of a property.  Thus we use a wildcard to match all of the ``dma_ctrl``
properties related to AXI, limited to just assert cells, and then convert them
to assume cells.  Provided the AXI is properly connected and valid, this ensures
that any other properties relying on the ``dma_ctrl`` can also be verified.

.. |cmdref for chformal| replace:: command reference page for ``chformal``
.. _cmdref for chformal: https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/chformal.html

The keep-going flag
~~~~~~~~~~~~~~~~~~~

At this stage of the process we may be ready to run the solver against all of
our properties rather than stopping at the first failure, and increasing the
depth of BMC.  We can do this by adding the ``--keep-going`` flag to our engine,
e.g. ``smtbmc --keep-going``. In order to keep run time down there are a few
things worth considering.  First is the ``-flatten`` flag for ``prep``.  This
will flatten the circuit and allow additional course grain optimizations.  The
next is adding cutpoints for elements which are computationally difficult to
prove.  This could look like the following:

.. literalinclude:: _examples/veer_4.sby
    :language: sby
    :end-before: tee -o

Note that flattening the hierarchy means we have the ``dma_ctrl`` assertions
need to be referenced slightly differently.  Rather than
``dma_ctrl_default/assert...`` we now see
``veer_wrapper/veer.dma_ctrl.assert...``.  We have also added cutpoints for all
``$mul`` and ``$mem_v2`` cells, i.e. multipliers and memory blocks.  This does
of course mean that any properties which rely on correct and valid multipliers
or memories will now fail, but we can verify those separately.
